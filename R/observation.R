# --------------------------------------------
# Function for validity check
# --------------------------------------------
# Validate observations
#
# @param object observation object
validateObservation <- function(object) {
  errors <- character()
  rs <- object@rs
  resp <- object@resp

  if(!(rs@N == length(resp))) {
    msg <- paste("randomization sequence should have same length as response",
                 sep = "", collapse = "")
    errors <- c(errors, msg)
  }

  if(length(errors) == 0) TRUE else errors
}

# --------------------------------------------
# Class definition for observation
# --------------------------------------------

#' Observations
#'
#' Class for the the observed outcome of the trial, namely a randomization
#' sequence and a response.
#'
#' @slot rs observed randomization sequence, generated by \code{\link{genSeq}}
#' @slot resp observed response
#'
#' @name observation-class
#'
#' @exportClass observation
setClass("observation",
         slots = c(rs = "randSeq", resp = "numeric"),
         validity = validateObservation
         )


# --------------------------------------------
# Show function for observation
# --------------------------------------------

setMethod("show", "observation", function(object) {
  validObject(object)
  cat("\nObject of class \"", class(object)[1], "\"\n\n", sep = "")
  cat("Randomization sequence: \n")
  print(object@rs)
  cat("\n\n")
  cat("Response vector: \n", object@resp, "\n")
  cat("\n")
})



# --------------------------------------------
# Generic function genObs
# --------------------------------------------

#' Generates observations of a RCT
#'
#' Generate observed response corresponding to the observed randomization sequence.
#'
#' @param rs observed randomization sequence, generated by \code{\link[randomizeR]{genSeq}}
#' @param endp  \code{\link[randomizeR]{normEndp}} object indicating the endpoint of the responses
#' @param issue The observations can be affected by selection bias
#' (\code{\link[randomizeR]{selBias}}) or chronological bias (\code{\link[randomizeR]{chronBias}})
#'
#'
#' @examples
#' ## generate an observation corresponding to a randomization sequence
#' rs <- genSeq(rarPar(10))
#' endp <- normEndp(c(0,1), c(1,1))
#' # new in infeR
#' genObs(rs, endp)
#'
#' ## Observations with Selection Bias
#' issue <- selBias("CS", 4, "exact")
#' # new in infeR
#' genObs(rs, endp, issue)
#'
#' ## Observation with chronological Bias with linear time trend
#' issue <- chronBias("linT", 0.05, "exact")
#' genObs(rs, endp, issue)
#'
# ## Observations with missing values
# # from randomizeR
# rs<-genSeq(rarPar(50),1,15)
# endp <- normEndp(c(100,100),c(10,10))
# # new in infeR
# d<-dmVal("urn",c(0.1,0.4),2) # group A 0.1% missing values, group B 0.4%
# mv<-mVal(d,"treatment","RRS") # treatment, reduced reference set.
# obs<-genObs(rs, endp, mv)
#'
#' @return An object containing an object of class observation containing a
#' randomization sequence and the response vector.
#' @name generateObservation
NULL


# --------------------------------------------
# Methods for genObs
# --------------------------------------------

#' @rdname generateObservation
#'
#' @export
setGeneric("genObs", function(rs, endp, issue) standardGeneric("genObs"))

#' @rdname generateObservation
#'
#' @export
setMethod("genObs", signature(rs = "randSeq", endp = "endpoint", issue="missing"),
          function(rs, endp, issue){
            #Check mu and sigma lengths
            if(length(endp@mu) != rs@K)
              return(stop("Error: mu vector doesn't match number of treatment groups"))
            if(length(endp@sigma) != rs@K)
              return(stop("Error: sigma vector doesn't match number of treatment groups"))
            sd <- replace(rs@M, which(rs@M==0), endp@sigma[1])
            sd <- replace(sd, which(rs@M==1), endp@sigma[2])
            mean <- replace(rs@M, which(rs@M==0), endp@mu[1])
            mean <- replace(mean, which(rs@M==1), endp@mu[2])
            resp <- rnorm(rs@N, mean, sd)
            new("observation", rs = rs, resp = resp)
          }
)


#' @rdname generateObservation
#'
#' @export
setMethod("genObs", signature(rs = "randSeq", endp = "numeric", issue="missing"),
          function(rs, endp, issue){
            #Check mu and sigma lengths
            if(length(endp) != rs@N)
              return(stop("Length of outcome does not match randomization sequence"))
           new("observation", rs = rs, resp = endp)
          }
)


#' @rdname generateObservation
#'
#' @export
setMethod("genObs", signature(rs = "randSeq", endp = "endpoint", issue="selBias"),
          function(rs, endp, issue){
            #Check mu and sigma lengths
            if(length(endp@mu) != rs@K)
              stop("Error: mu vector is doesn't match number of treatment groups")
            if(length(endp@sigma) != rs@K)
              stop("Error: sigma vector is doesn't match number of treatment groups")
            sd <- replace(rs@M, which(rs@M==0), endp@sigma[1])
            sd <- replace(sd, which(rs@M==1), endp@sigma[2])
            mean <- replace(rs@M, which(rs@M==0), endp@mu[1])
            mean <- replace(mean, which(rs@M==1), endp@mu[2])
            resp <- rnorm(rs@N, mean, sd)
            eta <- issue@eta
            resp <- resp + getBias(rs@M, eta)
            new("observation", rs = rs, resp = resp)
          }
)


#' @rdname generateObservation
#'
#' @export
setMethod("genObs", signature(rs = "randSeq", endp = "endpoint", issue="chronBias"),
          function(rs, endp, issue){
            #Check mu and sigma lengths
            if(length(endp@mu) != rs@K)
              stop("Error: mu vector is doesn't match number of treatment groups")
            if(length(endp@sigma) != rs@K)
              stop("Error: sigma vector is doesn't match number of treatment groups")
            sd <- replace(rs@M, which(rs@M==0), endp@sigma[1])
            sd <- replace(sd, which(rs@M==1), endp@sigma[2])
            mean <- replace(rs@M, which(rs@M==0), endp@mu[1])
            mean <- replace(mean, which(rs@M==1), endp@mu[2])
            resp <- rnorm(rs@N, mean, sd)
            theta <- issue@theta
            type <- issue@type
            if(type == "linT"){
              resp <- resp + theta*1:rs@N
            } else if(type == "logT"){
              resp <- resp + log((1:rs@N)/rs@N)*theta
            } else if(type == "stepT"){
              saltus <- issue@saltus
              saltusVector <- c(rep(0, saltus - 1), rep(theta, rs@N - saltus + 1))
              resp <- resp + saltusVector
            }
            new("observation", rs = rs, resp = resp)
          }
)
